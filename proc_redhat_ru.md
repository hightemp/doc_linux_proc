## Оглавление

- [Оглавление](#оглавление)
- [Источники](#источники)
- [Описание](#описание)
  - [3.1. Виртуальная файловая система](#31-виртуальная-файловая-система)
    - [3.1.1. Просмотр виртуальных файловая](#311-просмотр-виртуальных-файловая)
    - [3.1.2. Изменение виртуальных файловая](#312-изменение-виртуальных-файловая)
  - [3.2. Файлы верхнего уровня в файловой системе proc](#32-файлы-верхнего-уровня-в-файловой-системе-proc)
    - [3.2.1. /proc/apm](#321-procapm)
    - [3.2.2. /proc/buddyinfo](#322-procbuddyinfo)
    - [3.2.3. /proc/cmdline](#323-proccmdline)
    - [3.2.4. /proc/cpuinfo](#324-proccpuinfo)
    - [3.2.5. /proc/crypto](#325-proccrypto)
    - [3.2.6. /proc/devices](#326-procdevices)
    - [3.2.7. /proc/dma](#327-procdma)
    - [3.2.8. /proc/execdomains](#328-procexecdomains)
    - [3.2.9. /proc/fb](#329-procfb)
    - [3.2.10. /proc/filesystems](#3210-procfilesystems)
    - [3.2.11. /proc/interrupts](#3211-procinterrupts)
    - [3.2.12. /proc/iomem](#3212-prociomem)
    - [3.2.13. /proc/ioports](#3213-procioports)
    - [3.2.14. /proc/kcore](#3214-prockcore)
    - [3.2.15. /proc/kmsg](#3215-prockmsg)
    - [3.2.16. /proc/loadavg](#3216-procloadavg)
    - [3.2.17. /proc/locks](#3217-proclocks)
    - [3.2.18. /proc/mdstat](#3218-procmdstat)
    - [3.2.19. /proc/meminfo](#3219-procmeminfo)
    - [3.2.20. /proc/misc](#3220-procmisc)
    - [3.2.21. /proc/modules](#3221-procmodules)
    - [3.2.22. /proc/mounts](#3222-procmounts)
    - [3.2.23. /proc/mtrr](#3223-procmtrr)
    - [3.2.24. /proc/partitions](#3224-procpartitions)
    - [3.2.25. /proc/pci](#3225-procpci)
    - [3.2.26. /proc/slabinfo](#3226-procslabinfo)
    - [3.2.27. /proc/stat](#3227-procstat)
    - [3.2.28. /proc/swaps](#3228-procswaps)
    - [3.2.29. /proc/sysrq-trigger](#3229-procsysrq-trigger)
    - [3.2.30. /proc/uptime](#3230-procuptime)
    - [3.2.31. /proc/version](#3231-procversion)
  
## Источники

- https://web.mit.edu/rhel-doc/5/RHEL-5-manual/Deployment_Guide-en-US/ch-proc.html

## Описание

Ядро Linux имеет две основные функции: контролировать доступ к физическим устройствам на компьютере и планировать, когда и как процессы взаимодействуют с этими устройствами. Каталог /proc/ , также называемый файловой системой proc , содержит иерархию специальных файлов, представляющих текущее состояние ядра, что позволяет приложениям и пользователям заглянуть в представление ядра о системе.

В каталоге /proc/ можно найти огромное количество информации о системном оборудовании и любых запущенных процессах. Кроме того, пользователи и приложения могут манипулировать некоторыми файлами в дереве каталогов /proc/ , чтобы сообщать об изменениях конфигурации ядру.

### 3.1. Виртуальная файловая система

В Linux все данные хранятся в виде файлов. Большинство пользователей знакомы с двумя основными типами файлов: текстовыми и двоичными. Но каталог /proc/ содержит файл другого типа, называемый виртуальным файлом . Именно по этой причине /proc/ часто называют виртуальной файловой системой .

Эти виртуальные файлы обладают уникальными качествами. Размер большинства из них равен нулю, но при просмотре одного из них может содержаться большой объем информации. Кроме того, большинство настроек времени и даты в виртуальных файлах отражают текущее время и дату, что свидетельствует о том, что они постоянно обновляются.

Виртуальные файлы, такие как /proc/interrupts , /proc/meminfo , / proc/mounts и /proc/partitions , дают представление об аппаратном обеспечении системы на данный момент. Другие, такие как файл /proc/filesystems и каталог /proc/sys/ , предоставляют информацию о конфигурации системы и интерфейсы.

В организационных целях файлы, содержащие информацию по похожей теме, сгруппированы в виртуальные каталоги и подкаталоги. Например, /proc/ide/ содержит информацию обо всех физических устройствах IDE. Точно так же каталоги процессов содержат информацию о каждом запущенном процессе в системе.

#### 3.1.1. Просмотр виртуальных файловая

Используя команды cat , more или less для файлов в каталоге /proc/ , пользователи могут получить немедленный доступ к огромному количеству информации о системе. Например, чтобы отобразить тип ЦП компьютера, введите cat /proc/cpuinfo , чтобы получить вывод, подобный следующему:

При просмотре различных виртуальных файлов в файловой системе /proc/ часть информации легко понятна, а часть не читается человеком. Отчасти поэтому существуют утилиты для извлечения данных из виртуальных файлов и их удобного отображения. Примеры этих утилит включают lspci , apm , free и top .

#### 3.1.2. Изменение виртуальных файловая

Как правило, большинство виртуальных файлов в каталоге /proc/ доступны только для чтения. Однако некоторые из них можно использовать для настройки параметров ядра. Это особенно верно для файлов в подкаталоге /proc/sys/ .

Чтобы изменить значение виртуального файла, используйте команду echo и символ «больше» ( > ), чтобы перенаправить новое значение в файл. Например, чтобы изменить имя хоста на лету, введите:

```
echo www.example.com > /proc/sys/kernel/hostname
```

Другие файлы действуют как двоичные или логические переключатели. Ввод cat /proc/sys/net/ipv4/ip_forward возвращает либо 0 , либо 1. 
0 указывает, что ядро не пересылает сетевые пакеты . Использование команды echo для изменения значения файла ip_forward на 1 немедленно включает пересылку пакетов.

### 3.2. Файлы верхнего уровня в файловой системе proc

Ниже приведен список наиболее полезных виртуальных файлов верхнего уровня каталога /proc/ .

#### 3.2.1. /proc/apm

Этот файл предоставляет информацию о состоянии системы Advanced Power Management (APM) и используется командой apm . Если система без батареи подключена к источнику питания переменного тока, этот виртуальный файл будет выглядеть следующим образом:

```
1.16 1.2 0x07 0x01 0xff 0x80 -1% -1 ?
```

Выполнение команды apm -v в такой системе приводит к выводу, подобному следующему:

```
APM BIOS 1.2 (kernel driver 1.16ac) AC on-line, no system battery
```

Для систем, которые не используют батарею в качестве источника питания, apm может сделать немного больше, чем перевести машину в режим ожидания. Команда apm гораздо полезнее на ноутбуках. Например, следующий вывод получен командой cat /proc/apm на ноутбуке, подключенном к розетке:

```
1.16 1.2 0x03 0x01 0x03 0x09 100% -1 ?
```

Когда тот же ноутбук отключается от источника питания на несколько минут, содержимое файла apm изменяется примерно на следующее:

```
1.16 1.2 0x03 0x00 0x00 0x01 99% 1792 min
```

Команда apm -v теперь дает больше полезных данных, таких как следующие:

```
APM BIOS 1.2 (kernel driver 1.16) AC off-line, battery status high: 99% (1 day, 5:52)
```

#### 3.2.2. /proc/buddyinfo

Этот файл используется в основном для диагностики проблем с фрагментацией памяти. Используя алгоритм напарника, каждый столбец представляет собой количество страниц определенного порядка (определенного размера), доступных в любой момент времени. Например, для зоны DMA (прямой доступ к памяти) имеется 90 блоков памяти размером 2^(0*PAGE_SIZE). Точно так же доступно 6 блоков памяти размером 2^(1*PAGE_SIZE) и 2 блока памяти размером 2^(2*PAGE_SIZE).

Строка DMA ссылается на первые 16 МБ в системе, строка HighMem ссылается на всю память более 4 ГБ в системе, а строка Normal ссылается на всю память между ними.

Ниже приведен пример вывода, типичного для /proc/buddyinfo :

```
Node 0, zone      DMA     90      6      2      1      1      ... 
Node 0, zone   Normal   1650    310      5      0      0      ... 
Node 0, zone  HighMem      2      0      0      1      1      ...
```

#### 3.2.3. /proc/cmdline

Этот файл показывает параметры, переданные ядру во время его запуска. Пример файла /proc/cmdline выглядит следующим образом:

```
ro root=/dev/VolGroup00/LogVol00 rhgb quiet 3
```

Это говорит нам о том, что ядро смонтировано только для чтения (обозначается (ro) ), расположено на первом логическом томе ( LogVol00 ) первой группы томов ( /dev/VolGroup00 ). LogVol00 является эквивалентом раздела диска в системе, отличной от LVM (управление логическими томами), точно так же, как /dev/VolGroup00 похож по концепции на /dev/hda1 , но гораздо более расширяем.

Для получения дополнительной информации о LVM, используемом в Red Hat Enterprise Linux, обратитесь к http://www.tldp.org/HOWTO/LVM-HOWTO/index.html .

Затем rhgb сигнализирует, что пакет rhgb установлен и графическая загрузка поддерживается, при условии, что /etc/inittab показывает уровень выполнения по умолчанию, установленный на id:5:initdefault: .

Наконец, тихо указывает, что все подробные сообщения ядра подавляются во время загрузки.

#### 3.2.4. /proc/cpuinfo

Этот виртуальный файл определяет тип процессора, используемого вашей системой. Ниже приведен пример вывода, типичного для /proc/cpuinfo:

```
processor	: 0 
vendor_id	: GenuineIntel 
cpu family	: 15 
model		: 2 
model name	: Intel(R) Xeon(TM) CPU 2.40GHz 
stepping	: 7 cpu 
MHz		: 2392.371 
cache size	: 512 KB 
physical id	: 0 
siblings	: 2 
runqueue	: 0 
fdiv_bug	: no 
hlt_bug		: no 
f00f_bug	: no 
coma_bug	: no 
fpu		: yes 
fpu_exception	: yes 
cpuid level	: 2 
wp		: yes 
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca  cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm 
bogomips	: 4771.02
```

processor — Предоставляет каждому процессору идентификационный номер. В системах с одним процессором присутствует только 0.

cpu family — достоверно определяет тип процессора в системе. Для системы на базе Intel поместите число перед «86», чтобы определить значение. Это особенно полезно для тех, кто пытается определить архитектуру более старой системы, такой как 586, 486 или 386. Поскольку некоторые RPM-пакеты скомпилированы для каждой из этих конкретных архитектур, это значение также помогает пользователям определить, какие пакеты устанавливать.

model name — Отображает общее имя процессора, включая имя его проекта.

cpu MHz — показывает точную скорость процессора в мегагерцах с точностью до тысячных десятичных знаков.

cache size — отображает объем кэш-памяти уровня 2, доступный процессору.

siblings — отображает количество одноуровневых ЦП на одном физическом ЦП для архитектур, использующих гиперпоточность.

flags — определяет ряд различных характеристик процессора, таких как наличие модуля с плавающей запятой (FPU) и возможность обработки инструкций MMX.

#### 3.2.5. /proc/crypto

В этом файле перечислены все установленные криптографические шифры, используемые ядром Linux, включая дополнительные сведения о каждом из них. Пример файла /proc/crypto выглядит следующим образом:

```
name         : sha1 
module       : kernel 
type         : digest 
blocksize    : 64 
digestsize   : 20   
name         : md5 
module       : md5 
type         : digest 
blocksize    : 64 
digestsize   : 16
```

#### 3.2.6. /proc/devices

В этом файле отображаются различные сконфигурированные в данный момент символьные и блочные устройства (не включая устройства, модули которых не загружены). Ниже приведен пример вывода из этого файла:

```
Character devices:  
  1 mem   
  4 /dev/vc/0   
  4 tty   
  4 ttyS   
  5 /dev/tty   
  5 /dev/console   
  5 /dev/ptmx   
  7 vcs  
  10 misc  
  13 input  
  29 fb  
  36 netlink 
  128 ptm 
  136 pts 
  180 usb   
  
Block devices:   
  1 ramdisk   
  3 ide0   
  9 md  
  22 ide1 
  253 device-mapper 
  254 mdp
```

Вывод из /proc/devices включает в себя старший номер и имя устройства и разбит на два основных раздела: Символьные устройства и Блочные устройства.

Символьные устройства похожи на блочные, за исключением двух основных отличий:

Символьные устройства не требуют буферизации. Блочные устройства имеют доступный буфер, позволяющий им упорядочивать запросы перед их адресацией. Это важно для устройств, предназначенных для хранения информации, таких как жесткие диски, потому что возможность упорядочивать информацию перед ее записью на устройство позволяет размещать ее в более эффективном порядке.

Символьные устройства отправляют данные без предварительно настроенного размера. Блочные устройства могут отправлять и получать информацию блоками, размер которых настроен для каждого устройства.

Дополнительные сведения об устройствах см. в следующей установленной документации:

```
/usr/share/doc/kernel-doc-<version>/Documentation/devices.txt
```

#### 3.2.7. /proc/dma

Этот файл содержит список зарегистрированных используемых каналов DMA ISA. Пример файлов /proc/dma выглядит следующим образом:

```
4: cascade
```

#### 3.2.8. /proc/execdomains

В этом файле перечислены домены выполнения, поддерживаемые в настоящее время ядром Linux, а также диапазон поддерживаемых ими личностей.

```
0-0   Linux           [kernel]
```

Думайте о доменах выполнения как о «личности» операционной системы. Поскольку другие двоичные форматы, такие как Solaris, UnixWare и FreeBSD, могут использоваться с Linux, программисты могут изменить способ обработки операционной системой системных вызовов из этих двоичных файлов, изменив характер задачи. За исключением домена исполнения PER_LINUX, различные личности могут быть реализованы в виде динамически загружаемых модулей.

#### 3.2.9. /proc/fb

Этот файл содержит список устройств кадрового буфера с номером устройства кадрового буфера и управляющим им драйвером. Типичный вывод /proc/fb для систем, содержащих устройства кадрового буфера, выглядит следующим образом:

```
0 VESA VGA
```

#### 3.2.10. /proc/filesystems

Этот файл отображает список типов файловых систем, поддерживаемых в настоящее время ядром. Пример вывода универсального файла /proc/filesystems выглядит следующим образом:

```
nodev   sysfs 
nodev   rootfs 
nodev   bdev 
nodev   proc 
nodev   sockfs 
nodev   binfmt_misc 
nodev   usbfs 
nodev   usbdevfs 
nodev   futexfs 
nodev   tmpfs 
nodev   pipefs 
nodev   eventpollfs 
nodev   devpts         
	ext2 
nodev   ramfs 
nodev   hugetlbfs         
	iso9660 
nodev   mqueue         
	ext3 
nodev   rpc_pipefs 
nodev   autofs
```

Первый столбец указывает, смонтирована ли файловая система на блочном устройстве. Те, которые начинаются с nodev, не монтируются на устройство. Во втором столбце перечислены имена поддерживаемых файловых систем.

Команда mount циклически перебирает перечисленные здесь файловые системы, если одна из них не указана в качестве аргумента.

#### 3.2.11. /proc/interrupts

Этот файл записывает количество прерываний на IRQ в архитектуре x86. Стандартный файл /proc/interrupts выглядит следующим образом:

```
  CPU0          
  0:   80448940          XT-PIC  timer   
  1:     174412          XT-PIC  keyboard   
  2:          0          XT-PIC  cascade   
  8:          1          XT-PIC  rtc  
 10:     410964          XT-PIC  eth0  
 12:      60330          XT-PIC  PS/2 Mouse  
 14:    1314121          XT-PIC  ide0  
 15:    5195422          XT-PIC  ide1 
NMI:          0  
ERR:          0
```

Для многопроцессорной машины этот файл может выглядеть несколько иначе:

```
	   CPU0       CPU1          
  0: 1366814704          0          XT-PIC  timer   
  1:        128        340    IO-APIC-edge  keyboard   
  2:          0          0          XT-PIC  cascade   
  8:          0          1    IO-APIC-edge  rtc  
 12:       5323       5793    IO-APIC-edge  PS/2 Mouse  
 13:          1          0          XT-PIC  fpu  
 16:   11184294   15940594   IO-APIC-level  Intel EtherExpress Pro 10/100 Ethernet  
 20:    8450043   11120093   IO-APIC-level  megaraid  
 30:      10432      10722   IO-APIC-level  aic7xxx  
 31:         23         22   IO-APIC-level  aic7xxx 
NMI:          0 
ERR:          0
```

Первый столбец относится к номеру IRQ. Каждый ЦП в системе имеет свой собственный столбец и свое количество прерываний на IRQ. В следующем столбце сообщается тип прерывания, а последний столбец содержит имя устройства, расположенного на этом IRQ.

Каждый из типов прерываний, представленных в этом файле, зависящих от архитектуры, означает что-то свое. Для машин x86 распространены следующие значения:

XT-PIC — это старые компьютерные прерывания AT.

IO-APIC-edge — сигнал напряжения на этом прерывании переходит от низкого к высокому, создавая фронт, где прерывание происходит и сигнализируется только один раз. Этот вид прерывания, а также прерывание уровня IO-APIC встречается только в системах с процессорами семейства 586 и выше.

IO-APIC-level — Генерирует прерывания, когда его сигнал напряжения высок, пока сигнал снова не станет низким.

#### 3.2.12. /proc/iomem

Этот файл показывает текущую карту системной памяти для каждого физического устройства:

```
00000000-0009fbff : System RAM
0009fc00-0009ffff : reserved 
000a0000-000bffff : Video RAM area
000c0000-000c7fff : Video ROM 
000f0000-000fffff : System ROM
00100000-07ffffff : System RAM   
00100000-00291ba8 : Kernel code
00291ba9-002e09cb : Kernel data 
e0000000-e3ffffff : VIA Technologies, Inc. VT82C597 [Apollo VP3] e4000000-e7ffffff : PCI Bus #01   
e4000000-e4003fff : Matrox Graphics, Inc. MGA G200 AGP   
e5000000-e57fffff : Matrox Graphics, Inc. MGA G200 AGP 
e8000000-e8ffffff : PCI Bus #01   
e8000000-e8ffffff : Matrox Graphics, Inc. MGA G200 AGP 
ea000000-ea00007f : Digital Equipment Corporation DECchip 21140 [FasterNet]
ea000000-ea00007f : tulip ffff0000-ffffffff : reserved
```

В первом столбце отображаются регистры памяти, используемые каждым из различных типов памяти. Во втором столбце перечислены типы памяти, расположенной в этих регистрах, и показано, какие регистры памяти используются ядром в системной ОЗУ, или, если сетевая карта имеет несколько портов Ethernet, регистры памяти, назначенные для каждого порта.

#### 3.2.13. /proc/ioports

Вывод /proc/ioports предоставляет список зарегистрированных в настоящее время областей портов, используемых для ввода или вывода связи с устройством. Этот файл может быть довольно длинным. Ниже приводится частичный список:

```
0000-001f : dma1 
0020-003f : pic1 
0040-005f : timer 
0060-006f : keyboard 
0070-007f : rtc 
0080-008f : dma page reg 
00a0-00bf : pic2 
00c0-00df : dma2 
00f0-00ff : fpu 
0170-0177 : ide1 
01f0-01f7 : ide0 
02f8-02ff : serial(auto) 
0376-0376 : ide1 
03c0-03df : vga+ 
03f6-03f6 : ide0 
03f8-03ff : serial(auto) 
0cf8-0cff : PCI conf1 
d000-dfff : PCI Bus #01 
e000-e00f : VIA Technologies, Inc. Bus Master IDE   
e000-e007 : ide0   
e008-e00f : ide1 
e800-e87f : Digital Equipment Corporation DECchip 21140 [FasterNet]   
e800-e87f : tulip
```

В первом столбце указан диапазон адресов портов ввода/вывода, зарезервированный для устройства, указанного во втором столбце.

#### 3.2.14. /proc/kcore

Этот файл представляет собой физическую память системы и хранится в формате основного файла. В отличие от большинства файлов /proc/, kcore отображает размер. Это значение указано в байтах и равно размеру используемой физической памяти (ОЗУ) плюс 4 КБ.

Содержимое этого файла предназначено для проверки отладчиком, таким как gdb, и не может быть прочитано человеком.

#### 3.2.15. /proc/kmsg

Этот файл используется для хранения сообщений, сгенерированных ядром. Затем эти сообщения перехватываются другими программами, такими как /sbin/klogd или /bin/dmesg.

#### 3.2.16. /proc/loadavg

Этот файл позволяет просмотреть среднюю загрузку ЦП и ввода-вывода с течением времени, а также дополнительные данные, используемые временем безотказной работы и другими командами. Пример файла /proc/loadavg выглядит следующим образом:

```
0.20 0.18 0.12 1/80 11206
```

В первых трех столбцах измеряется загрузка ЦП и операций ввода-вывода за последние 1, 5 и 10 минут. Четвертый столбец показывает количество запущенных в данный момент процессов и общее количество процессов. В последнем столбце отображается последний использованный идентификатор процесса.

#### 3.2.17. /proc/locks

Этот файл отображает файлы, в настоящее время заблокированные ядром. Содержимое этого файла содержит данные внутренней отладки ядра и может сильно различаться в зависимости от использования системы. Пример файла /proc/locks для малонагруженной системы выглядит следующим образом:

```
1: POSIX  ADVISORY  WRITE 3568 fd:00:2531452 0 EOF 
2: FLOCK  ADVISORY  WRITE 3517 fd:00:2531448 0 EOF 
3: POSIX  ADVISORY  WRITE 3452 fd:00:2531442 0 EOF 
4: POSIX  ADVISORY  WRITE 3443 fd:00:2531440 0 EOF 
5: POSIX  ADVISORY  WRITE 3326 fd:00:2531430 0 EOF 
6: POSIX  ADVISORY  WRITE 3175 fd:00:2531425 0 EOF 
7: POSIX  ADVISORY  WRITE 3056 fd:00:2548663 0 EOF
```

У каждого замка есть своя строка, которая начинается с уникального номера. Второй столбец относится к классу используемой блокировки, где FLOCK означает блокировку файлов UNIX в старом стиле из системного вызова flock, а POSIX представляет более новые блокировки POSIX из системного вызова lockf.

Третий столбец может иметь два значения: ADVISORY или MANDATORY. ADVISORY означает, что блокировка не препятствует доступу к данным других людей; это только предотвращает другие попытки заблокировать его. ОБЯЗАТЕЛЬНЫЙ означает, что никакой другой доступ к данным не разрешен, пока блокировка удерживается. Четвертый столбец показывает, разрешает ли блокировка доступ к файлу для ЧТЕНИЯ или ЗАПИСИ. Пятый столбец показывает идентификатор процесса, удерживающего блокировку. Шестой столбец показывает идентификатор заблокированного файла в формате ОСНОВНОЕ-УСТРОЙСТВО:МИНОР-УСТРОЙСТВО:НОМЕР-INODE. Седьмой и восьмой столбцы показывают начало и конец заблокированной области файла.

#### 3.2.18. /proc/mdstat

Этот файл содержит текущую информацию для многодисковых конфигураций RAID. Если в системе нет такой конфигурации, то /proc/mdstat выглядит примерно так:

```
Personalities :  read_ahead not set unused devices: <none>
```

Этот файл остается в том же состоянии, что и выше, если не присутствует программный RAID или устройство md. В этом случае просмотрите /proc/mdstat, чтобы узнать текущий статус устройств mdX RAID.

В приведенном ниже файле /proc/mdstat показана система с md0, настроенным как устройство RAID 1, в то время как в настоящее время выполняется повторная синхронизация дисков:

```
Personalities : [linear] [raid1] read_ahead 1024 sectors 
md0: active raid1 sda2[1] sdb2[0] 9940 blocks [2/2] [UU] resync=1% finish=12.3min algorithm 2 [3/3] [UUU] 
unused devices: <none>
```

#### 3.2.19. /proc/meminfo

Это один из наиболее часто используемых файлов в каталоге /proc/, так как он содержит большое количество ценной информации об использовании системной оперативной памяти.

Следующий образец виртуального файла /proc/meminfo взят из системы с 256 МБ ОЗУ и 512 МБ пространства подкачки:

```
MemTotal:       255908 kB 
MemFree:         69936 kB 
Buffers:         15812 kB 
Cached:         115124 kB 
SwapCached:          0 kB 
Active:          92700 kB 
Inactive:        63792 kB 
HighTotal:           0 kB 
HighFree:            0 kB 
LowTotal:       255908 kB 
LowFree:         69936 kB 
SwapTotal:      524280 kB 
SwapFree:       524280 kB 
Dirty:               4 kB 
Writeback:           0 kB 
Mapped:          42236 kB 
Slab:            25912 kB 
Committed_AS:   118680 kB 
PageTables:       1236 kB 
VmallocTotal:  3874808 kB 
VmallocUsed:      1416 kB 
VmallocChunk:  3872908 kB 
HugePages_Total:     0 
HugePages_Free:      0 
Hugepagesize:     4096 kB
```

Большая часть приведенной здесь информации используется командами free, top и ps. На самом деле вывод команды free похож на содержимое и структуру /proc/meminfo. Но если посмотреть непосредственно на /proc/meminfo, можно узнать больше деталей:

* MemTotal — общий объем физической оперативной памяти в килобайтах.
* MemFree — объем физической оперативной памяти в килобайтах, оставшейся неиспользованной системой.
* Buffers — объем физической оперативной памяти в килобайтах, используемый для файловых буферов.
* Cached — объем физической оперативной памяти в килобайтах, используемой в качестве кэш-памяти.
* SwapCached — объем свопа в килобайтах, используемый в качестве кэш-памяти.
* Active — общий объем памяти буфера или кэша страниц в килобайтах, который активно используется. Это память, которая недавно использовалась и обычно не используется для других целей.
* Inactive — общий объем свободной и доступной памяти буфера или кэша страниц в килобайтах. Это память, которая в последнее время не использовалась и может быть освобождена для других целей.
* HighTotal и HighFree — общий и свободный объем памяти в килобайтах, которая не отображается напрямую в пространство ядра. Значение HighTotal может варьироваться в зависимости от типа используемого ядра.
* LowTotal и LowFree — общий и свободный объем памяти в килобайтах, который напрямую отображается в пространство ядра. Значение LowTotal может варьироваться в зависимости от типа используемого ядра.
* SwapTotal — общий объем доступного свопа в килобайтах.
* SwapFree — общий объем свободной подкачки в килобайтах.
* Dirty — общий объем памяти в килобайтах, ожидающий обратной записи на диск.
* Writeback — общий объем памяти в килобайтах, активно записываемый обратно на диск.
* Mapped — общий объем памяти в килобайтах, который использовался для сопоставления устройств, файлов или библиотек с помощью команды mmap.
* Slab — общий объем памяти в килобайтах, используемый ядром для кэширования структур данных для собственного использования.
* Committed_AS — общий объем памяти в килобайтах, необходимый для выполнения рабочей нагрузки. Это значение соответствует наихудшему сценарию, а также включает память подкачки.
* PageTables — общий объем памяти в килобайтах, выделенный для самого нижнего уровня таблицы страниц.
* VMallocTotal — общий объем памяти в килобайтах общего выделенного виртуального адресного пространства.
* VMallocUsed — общий объем памяти в килобайтах используемого виртуального адресного пространства.
* VMallocChunk — самый большой непрерывный блок памяти в килобайтах доступного виртуального адресного пространства.
* HugePages_Total — общее количество огромных страниц в системе. Это число получается путем деления Hugepagesize на мегабайты, выделенные для огромных страниц, указанных в /proc/sys/vm/hugetlb_pool. Эта статистика появляется только для архитектур x86, Itanium и AMD64.
* HugePages_Free — общее количество огромных страниц, доступных для системы. Эта статистика появляется только для архитектур x86, Itanium и AMD64.
* Hugepagesize — размер каждого блока огромных страниц в килобайтах. По умолчанию значение составляет 4096 КБ для однопроцессорных ядер для 32-разрядных архитектур. Для SMP, ядер hugemem и AMD64 значение по умолчанию составляет 2048 КБ. Для архитектур Itanium значение по умолчанию равно 262144 КБ. Эта статистика появляется только для архитектур x86, Itanium и AMD64.

#### 3.2.20. /proc/misc

В этом файле перечислены различные драйверы, зарегистрированные на другом основном устройстве, которое имеет номер устройства 10:

```
63 device-mapper 175 agpgart 135 rtc 134 apm_bios
```

Первый столбец — это младший номер каждого устройства, а второй столбец показывает используемый драйвер.

#### 3.2.21. /proc/modules

Этот файл отображает список всех модулей, загруженных в ядро. Его содержимое зависит от конфигурации и использования вашей системы, но оно должно быть организовано так же, как в этом образце вывода файла /proc/modules:

```
nfs      170109  0 -          Live 0x129b0000 
lockd    51593   1 nfs,       Live 0x128b0000 
nls_utf8 1729    0 -          Live 0x12830000 
vfat     12097   0 -          Live 0x12823000 
fat      38881   1 vfat,      Live 0x1287b000 
autofs4  20293   2 -          Live 0x1284f000 
sunrpc   140453  3 nfs,lockd, Live 0x12954000 
3c59x    33257   0 -          Live 0x12871000 
uhci_hcd 28377   0 -          Live 0x12869000 
md5      3777    1 -          Live 0x1282c000 
ipv6     211845 16 -          Live 0x128de000 
ext3     92585   2 -          Live 0x12886000 
jbd      65625   1 ext3,      Live 0x12857000 
dm_mod   46677   3 -          Live 0x12833000
```

Первый столбец содержит имя модуля.

Второй столбец относится к размеру памяти модуля в байтах.

В третьем столбце указано, сколько экземпляров модуля загружено в данный момент. Нулевое значение представляет незагруженный модуль.

В четвертом столбце указано, зависит ли модуль от присутствия другого модуля для функционирования, и перечислены эти другие модули.

В пятом столбце указано, в каком состоянии загрузки находится модуль: Единственными возможными значениями являются Live, Loading или Unloading.

В шестом столбце указано текущее смещение памяти ядра для загруженного модуля. Эта информация может быть полезна для целей отладки или для инструментов профилирования, таких как oprofile.

#### 3.2.22. /proc/mounts

Этот файл содержит список всех монтирований, используемых системой:

```
rootfs / rootfs rw 0 0 
/proc /proc proc rw,nodiratime 0 0 none 
/dev ramfs rw 0 0 
/dev/mapper/VolGroup00-LogVol00 / ext3 rw 0 0 
none /dev ramfs rw 0 0 
/proc /proc proc rw,nodiratime 0 0 
/sys /sys sysfs rw 0 0 
none /dev/pts devpts rw 0 0 
usbdevfs /proc/bus/usb usbdevfs rw 0 0 
/dev/hda1 /boot ext3 rw 0 0 
none /dev/shm tmpfs rw 0 0 
none /proc/sys/fs/binfmt_misc binfmt_misc rw 0 0 
sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw 0 0
```

Найденный здесь вывод аналогичен содержимому /etc/mtab, за исключением того, что /proc/mount более актуален.

В первом столбце указано смонтированное устройство, во втором столбце — точка монтирования, в третьем — тип файловой системы, а в четвертом столбце указано, смонтировано ли оно только для чтения (ro) или для чтения и записи (rw ). Пятый и шестой столбцы являются фиктивными значениями, разработанными для соответствия формату, используемому в /etc/mtab.

#### 3.2.23. /proc/mtrr

Этот файл относится к текущим регистрам диапазона типов памяти (MTRR), используемым в системе. Если системная архитектура поддерживает MTRR, файл /proc/mtrr может выглядеть следующим образом:

```
reg00: base=0x00000000 (   0MB), size= 256MB: write-back, count=1 
reg01: base=0xe8000000 (3712MB), size=  32MB: write-combining, count=1
```

MTRR используются с семейством процессоров Intel P6 (Pentium II и выше) и управляют доступом процессора к диапазонам памяти. При использовании видеокарты на шине PCI или AGP правильно настроенный файл /proc/mtrr может повысить производительность более чем на 150%.

В большинстве случаев это значение правильно настроено по умолчанию. Дополнительную информацию о настройке этого файла вручную можно найти локально по следующему адресу:

```
/usr/share/doc/kernel-doc-<version>/Documentation/mtrr.txt
```

#### 3.2.24. /proc/partitions

Этот файл содержит информацию о распределении блоков разделов. Пример этого файла из базовой системы выглядит следующим образом:

```
major minor  #blocks  name      
  3     0   19531250 hda    
  3     1     104391 hda1    
  3     2   19422585 hda2  
253     0   22708224 dm-0  
253     1     524288 dm-1
```

Большая часть информации здесь не имеет большого значения для пользователя, за исключением следующих столбцов:

* major — старший номер устройства с этим разделом. Старший номер в /proc/partitions (3) соответствует ide0 блочного устройства в /proc/devices.
* minor — младший номер устройства с этим разделом. Это служит для разделения разделов на разные физические устройства и относится к числу в конце имени раздела.
* #blocks — показывает количество блоков физического диска, содержащихся в определенном разделе.
* name — Имя раздела.

#### 3.2.25. /proc/pci

Этот файл содержит полный список всех устройств PCI в системе. В зависимости от количества устройств PCI /proc/pci может быть довольно длинным. Пример этого файла из базовой системы выглядит следующим образом:

```
Bus  0, device 0, function 0: Host bridge: Intel Corporation 440BX/ZX - 82443BX/ZX Host bridge (rev 3). Master Capable. Latency=64. Prefetchable 32 bit memory at 0xe4000000 [0xe7ffffff].   
Bus  0, device 1, function 0: PCI bridge: Intel Corporation 440BX/ZX - 82443BX/ZX AGP bridge (rev 3).   Master Capable. Latency=64. Min Gnt=128.   
Bus  0, device 4, function 0: ISA bridge: Intel Corporation 82371AB PIIX4 ISA (rev 2).   
Bus  0, device 4, function 1: IDE interface: Intel Corporation 82371AB PIIX4 IDE (rev 1). Master Capable. Latency=32. I/O at 0xd800 [0xd80f].   
Bus  0, device 4, function 2: USB Controller: Intel Corporation 82371AB PIIX4 USB (rev 1). IRQ 5. Master Capable. Latency=32. I/O at 0xd400 [0xd41f].   
Bus  0, device 4, function 3: Bridge: Intel Corporation 82371AB PIIX4 ACPI (rev 2). IRQ 9.  
Bus  0, device 9, function 0: Ethernet controller: Lite-On Communications Inc LNE100TX (rev 33). IRQ 5. Master Capable. Latency=32. I/O at 0xd000 [0xd0ff].   
Bus  0, device 12, function  0: VGA compatible controller: S3 Inc. ViRGE/DX or /GX (rev 1). IRQ 11. Master Capable. Latency=32. Min Gnt=4.Max Lat=255.
```

Этот вывод показывает список всех устройств PCI, отсортированных в порядке шины, устройства и функции. Помимо указания имени и версии устройства, этот список также содержит подробную информацию о IRQ, чтобы администратор мог быстро найти конфликты.

#### 3.2.26. /proc/slabinfo

Этот файл дает полную информацию об использовании памяти slab level. Ядра Linux старше версии 2.2 используют slab pools для управления памятью выше уровня страниц. Обычно используемые объекты имеют свои собственные slab pools.

Вместо того, чтобы анализировать очень подробный файл /proc/slabinfo вручную, программа /usr/bin/slabtop отображает информацию кэша slab ядра в режиме реального времени. Эта программа позволяет настраивать пользовательские конфигурации, включая сортировку столбцов и обновление экрана.

Пример снимка экрана /usr/bin/slabtop обычно выглядит следующим образом:

```
Active / Total Objects (% used)    : 133629 / 147300 (90.7%)  
Active / Total Slabs (% used)      : 11492 / 11493 (100.0%)  
Active / Total Caches (% used)     : 77 / 121 (63.6%)  
Active / Total Size (% used)       : 41739.83K / 44081.89K (94.7%)  
Minimum / Average / Maximum Object : 0.01K / 0.30K / 128.00K
OBJS   ACTIVE USE      OBJ   SIZE     SLABS OBJ/SLAB CACHE SIZE NAME  
44814  43159  96%    0.62K   7469      6     29876K ext3_inode_cache
36900  34614  93%    0.05K    492     75      1968K buffer_head  
35213  33124  94%    0.16K   1531     23      6124K dentry_cache   
7364   6463  87%    0.27K    526      14      2104K radix_tree_node   
2585   1781  68%    0.08K     55      47       220K vm_area_struct   
2263   2116  93%    0.12K     73      31       292K size-128   
1904   1125  59%    0.03K     16      119        64K size-32   
1666    768  46%    0.03K     14      119        56K anon_vma   
1512   1482  98%    0.44K    168       9       672K inode_cache   
1464   1040  71%    0.06K     24      61        96K size-64   
1320    820  62%    0.19K     66      20       264K filp    
678    587  86%    0.02K      3      226        12K dm_io   
678    587  86%    0.02K      3      226        12K dm_tio    
576    574  99%    0.47K     72        8       288K proc_inode_cache    
528    514  97%    0.50K     66        8       264K size-512    
492    372  75%    0.09K     12       41        48K bio    
465    314  67%    0.25K     31       15       124K size-256    
452    331  73%    0.02K      2      226         8K biovec-1    
420    420 100%    0.19K     21       20        84K skbuff_head_cache    
305    256  83%    0.06K      5       61        20K biovec-4    
290      4   1%    0.01K      1      290         4K revoke_table    
264    264 100%    4.00K    264        1      1056K size-4096    
260    256  98%    0.19K     13       20        52K biovec-16    
260    256  98%    0.75K     52        5       208K biovec-64
```

Некоторые из наиболее часто используемых статистических данных в /proc/slabinfo, включенных в /usr/bin/slabtop, включают:

* OBJS — общее количество объектов (блоков памяти), включая используемые (выделенные) и некоторые неиспользуемые запасные части.
* ACTIVE — количество объектов (блоков памяти), которые используются (выделены).
* USE — Процент активных объектов от общего числа. ((АКТИВ/ОБЪЕКТЫ)(100))
* OBJ SIZE — Размер объектов.
* SLABS — общее количество плит.
* OBJ/SLAB — количество объектов, помещающихся в плиту.
* CACHE SIZE — размер кэша slab.
* NAME — Имя плиты.

Для получения дополнительной информации о программе /usr/bin/slabtop обратитесь к справочной странице slabtop.

#### 3.2.27. /proc/stat

Этот файл отслеживает различные статистические данные о системе с момента ее последнего перезапуска. Содержимое /proc/stat, которое может быть довольно длинным, обычно начинается примерно так:

```
cpu  259246 7001 60190 34250993 137517 772 0 
cpu0 259246 7001 60190 34250993 137517 772 0 
intr 354133732 347209999 2272 0 4 4 0 0 3 1 1249247 0 0 80143 0 422626 5169433 
ctxt 12547729 
btime 1093631447 
processes 130523 
procs_running 1 
procs_blocked 0 
preempt 5651840  
cpu  209841 1554 21720 118519346 72939 154 27168 
cpu0 42536 798 4841 14790880 14778 124 3117 
cpu1 24184 569 3875 14794524 30209 29 3130 
cpu2 28616 11 2182 14818198 4020 1 3493 
cpu3 35350 6 2942 14811519 3045 0 3659 
cpu4 18209 135 2263 14820076 12465 0 3373 
cpu5 20795 35 1866 14825701 4508 0 3615 
cpu6 21607 0 2201 14827053 2325 0 3334 
cpu7 18544 0 1550 14831395 1589 0 3447 
intr 15239682 14857833 6 0 6 6 0 5 0 1 0 0 0 29 0 2 0 0 0 0 0 0 0 94982 0 286812 
ctxt 4209609 
btime 1078711415 
processes 21905 
procs_running 1 
procs_blocked 0
```

Некоторые из наиболее часто используемых статистических данных включают в себя:

* cpu — измеряет количество мигов (1/100 секунды для систем x86), в течение которых система находилась в пользовательском режиме, пользовательском режиме с низким приоритетом (хорошем), системном режиме, бездействующей задаче, ожидании ввода-вывода, ) и softirq соответственно. IRQ (hardirq) — это прямой ответ на аппаратное событие. IRQ требует минимальной работы для постановки в очередь «тяжелой» работы для выполнения softirq. Программное прерывание выполняется с более низким приоритетом, чем IRQ, и поэтому может прерываться чаще. Сумма для всех ЦП указана вверху, а каждый отдельный ЦП указан ниже со своей собственной статистикой. В следующем примере показана четырехпроцессорная конфигурация Intel Pentium Xeon с включенной многопоточностью, поэтому показаны четыре физических процессора и четыре виртуальных процессора, всего восемь процессоров.
* page — количество страниц памяти, записанных системой на диск и записанных на него.
* swap — количество страниц подкачки, которые система ввела и вывела.
* intr — количество прерываний, которые система испытала.
* btime — время загрузки, измеренное в секундах с 1 января 1970 года, также известное как эпоха.

#### 3.2.28. /proc/swaps

Этот файл измеряет пространство подкачки и его использование. Для системы только с одним разделом подкачки вывод /proc/swaps может выглядеть следующим образом:

```
Filename                          Type        Size     Used    Priority 
/dev/mapper/VolGroup00-LogVol01   partition   524280   0       -1
```

Хотя часть этой информации можно найти в других файлах в каталоге /proc/, /proc/swap предоставляет моментальный снимок каждого имени файла подкачки, типа пространства подкачки, общего размера и объема используемого пространства (в килобайт). Столбец приоритета полезен, когда используется несколько файлов подкачки. Чем ниже приоритет, тем больше вероятность использования файла подкачки.

#### 3.2.29. /proc/sysrq-trigger

Используя команду echo для записи в этот файл, удаленный пользователь root может выполнять большинство команд ключа системного запроса удаленно, как если бы он был на локальном терминале. Чтобы отображать значения в этот файл, для параметра /proc/sys/kernel/sysrq должно быть установлено значение, отличное от 0. Для получения дополнительной информации о ключе системного запроса см. Раздел 3.3.9.3, "/proc/sys/kernel/".

Хотя в этот файл можно записывать, он не может быть прочитан даже пользователем root.

#### 3.2.30. /proc/uptime

Этот файл содержит информацию о том, как долго система работала с момента последней перезагрузки. Вывод /proc/uptime весьма минимален:

```
350735.47 234388.90
```

Первое число — это общее количество секунд, в течение которых система работала. Второе число показывает, сколько из этого времени машина провела в режиме ожидания в секундах.

#### 3.2.31. /proc/version

В этом файле указывается используемая версия ядра Linux и gcc, а также версия Red Hat Enterprise Linux, установленная в системе:

```
Linux version 2.6.8-1.523 (user@foo.redhat.com) (gcc version 3.4.1 20040714 \  (Red Hat Enterprise Linux 3.4.1-7)) #1 Mon Aug 16 13:27:03 EDT 2004
```

Эта информация используется для различных целей, включая данные о версии, представленные при входе пользователя в систему.




https://web.mit.edu/rhel-doc/5/RHEL-5-manual/Deployment_Guide-en-US/s1-proc-directories.html

